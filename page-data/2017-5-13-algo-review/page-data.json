{"componentChunkName":"component---src-templates-post-tsx","path":"/2017-5-13-algo-review/","result":{"data":{"site":{"siteMetadata":{"title":"lshadler","description":"A personal website for Lucas Shadler","author":{"name":"Lucas Shadler","url":"https://github.intuit.com/sumwatshade"}}},"markdownRemark":{"html":"<h2>Basic Concepts</h2>\n<h3>Complexity</h3>\n<p>An algorithm is efficient if it runs in polynomial time or better.</p>\n<h4>Big-O</h4>\n<p>Denotes worst case running time, a bound on the largest possible run time given\ninput of size N.\nTheta is lower and upper bound</p>\n<blockquote>\n<p>1 &#x3C; log n &#x3C; n &#x3C; n log n &#x3C; n^2 &#x3C; n^3 &#x3C; a^n &#x3C; n!</p>\n</blockquote>\n<h4>Amortized</h4>\n<p>Average running time per operation over a worst-case sequence of operation</p>\n<ul>\n<li>Ex. Size-doubling array: 2^n operation every 2^ith step, but constant step</li>\n</ul>\n<p>otherwise. Hence, O(n) with constant amortized time</p>\n<h3>Stable Matching</h3>\n<p>Given a set of preferences among hospitals and medical school students, design\na self-reinforcing admissions process</p>\n<ul>\n<li>Unstable paier: x and y are unstable if\n<ul>\n<li>x prefers y and y prefers x to their assigned groupign</li>\n</ul>\n</li>\n<li>Stable Assignment: Assignment with no unstable pairs</li>\n<li>Perfect matching: Everyone has a single unique match</li>\n</ul>\n<h4>Propose-and-reject algorithm</h4>\n<ul>\n<li>Gale-Shapely</li>\n<li>Guarantees a stable matching for any problem</li>\n<li>Gives a proposing-optimal assignment</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while some man is free and hasn't proposed to every woman\n\tchoose such a man m\n\tw = first woman on m's list he has not proposed to\n\tif w is free\n\t\tassign m and w together\n\telse if w prefers m to her fiance m'\n\t\tassign m and w to be engaged, m' is free\n\telse\n\t\tw rejects m</code></pre></div>\n<h3>Data Structures</h3>\n<h4>Linked List</h4>\n<ul>\n<li>Each data node is linked to the next</li>\n<li>Access: O(n)</li>\n<li>Insert: O(1)</li>\n<li>head - first node in list</li>\n<li>tail - last node in list</li>\n</ul>\n<h4>Stack</h4>\n<ul>\n<li>Last in, First out</li>\n<li>Access: O(1)</li>\n<li>Insert: O(1)</li>\n<li>push(), pop()</li>\n<li>Implement with linked list</li>\n</ul>\n<h4>Queue</h4>\n<ul>\n<li>First in, First out</li>\n<li>Access: O(1)</li>\n<li>Insert: O(1) if doubly linked list</li>\n</ul>\n<h4>Searching</h4>\n<ul>\n<li>A <strong>linear search</strong> can be performed on a sorted sequence O(n)</li>\n<li><strong>Binary Search</strong>: Divide-and-conquer on sorted sequence O(log n)</li>\n</ul>\n<h4>Sorting</h4>\n<ul>\n<li><strong>Bubble Sort</strong>: Arranges items by iterating over the sequence, putting larger</li>\n</ul>\n<p>values on the top piece by piece, swap if left > right adjacent. O(n^2)</p>\n<ul>\n<li><strong>Selection Sort</strong>: Repeatedly select the next smallest item from unsorted</li>\n</ul>\n<p>items O(n^2)</p>\n<ul>\n<li><strong>Insertion Sort</strong>: Iterates over sorted sequence, inserts the next</li>\n</ul>\n<p>unsorted item into its proper place O(n^2)</p>\n<ul>\n<li><strong>Heap Sort</strong>: Build heap and extract keys in sorted sequence O(n log n)</li>\n</ul>\n<h4>Heap Trees</h4>\n<p>A heap is a complete binary tree in which the nodes are organied based on their\ndata values</p>\n<ul>\n<li>Max heap: The value is greater than its two children</li>\n<li>Min heap: The value is smaller than its two children</li>\n<li>Can only remove from the root node</li>\n<li>Inserts in next available left/top location, and sift upwards</li>\n<li>can be stored in a dynamic array\n<ul>\n<li>parent = i // 2</li>\n<li>left = 2 * i</li>\n<li>right = 2 * i + 1</li>\n</ul>\n</li>\n<li>Insertion: O(log n)</li>\n<li>Extraction: O(log n)</li>\n<li>Building\n<ul>\n<li>Top down: Heaps constructed by inserting into an empty heap O(n log n)</li>\n<li>Bottom up: Put everything in array and then fix O(n)</li>\n</ul>\n</li>\n</ul>\n<h4>BST</h4>\n<p>Tree such that all keys less than current key is in the left subtree and all\nkeys greater than the key are stored in the right subtree</p>\n<ul>\n<li>Searching is trivial</li>\n<li>Can be built recursively or iteratively</li>\n<li>Removing\n<ul>\n<li>Remove interior node -></li>\n<li>Successor: Minimum key in right subtree</li>\n</ul>\n</li>\n<li>Search, insert, delete: O(n)</li>\n</ul>\n<h5>AVL Trees</h5>\n<p>Developed by Adel’son-Velskhii and Landis to guarantee that the tree is height\nbalanced</p>\n<h3>Master Theorem</h3>\n<h2>Algorithm Subcategories</h2>\n<h3>Divide and Conquer</h3>\n<ul>\n<li>Break up problem into several parts</li>\n<li>solve each part recursively</li>\n<li>combine solutions to sub-problems into overall solution</li>\n<li>n^2 -> n log n</li>\n</ul>\n<h4>Mergesort</h4>\n<ul>\n<li>Divide array into two halves</li>\n<li>recursively sort each half</li>\n<li>merge two halves to make a sorted whole</li>\n</ul>\n<h4>Convex Hull</h4>\n<p>Given a set of points, find the smallest convex polygon containing all the\npoints</p>\n<p>Graham-scan</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">start at bottom-left point\nsort points by relative polar angle\nbegin\n\tadd point to stack\n\tpop off if it creates a left turn\n</code></pre></div>\n<h4>Counting Inversion</h4>\n<p>Find number of inversions made to match two lists</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if list L has one element\n\treturn 0 and list L\nDivide L into two halves A and B\n(ra, A) = function(A)\n(rb, B) = function(B)\n(r, L)  = merge-and-count(A,B)\nreturn r = ra + rb + r and sorted list L</code></pre></div>\n<h3>Greedy Algorithms</h3>\n<ul>\n<li>Build up solutions in small steps</li>\n<li>Make local decisions</li>\n<li>Previous decisions do not factor into the next consideration</li>\n</ul>\n<h4>Coin changing</h4>\n<p>Given currency denominations, devise a method to pay amount to customer using\nfewest number of coins</p>\n<ul>\n<li>At each iteration, add coin of largest value that does not take us past the</li>\n</ul>\n<p>amount to be paid\n* Optimal for US coinage\n* Suboptimal for other situations (1, 10, 21, 34, 70, 100):(140)</p>\n<h4>Interval Scheduling</h4>\n<p>Find the maximal subset of mutually compatible jobs</p>\n<ul>\n<li>Consider ordering\n<ul>\n<li>Earliest Start time</li>\n<li>Earliest finish time</li>\n<li>Shortest interval</li>\n<li>fewest conflicts</li>\n<li><strong>Typically Finish Time is Optimal</strong></li>\n</ul>\n</li>\n<li>Unweighted solution: Take the next valid job based on finish time and no</li>\n</ul>\n<p>conflicts</p>\n<ul>\n<li>O(n log(n))</li>\n</ul>\n<h4>Interval Partitioning</h4>\n<p>Find minimum number of classrooms to schedule all lectures so that no two occur\nat the same time</p>\n<ul>\n<li>number of classrooms needed >= depth</li>\n<li>Sort by start time</li>\n<li>Assign lecture to any compatible classroom</li>\n<li>O(n log(n))</li>\n</ul>\n<h3>Dynamic Programming</h3>\n<p>Develop a solution as a solution to several subproblems, and get benefits in\nperformance as a result of the division of computation.</p>\n<h4>Weighted Interval Scheduling</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n<h4>Knapsack</h4>\n<p>Given:</p>\n<ul>\n<li>A collection of n items</li>\n<li>Each item has a weight w</li>\n<li>each item has a value c</li>\n<li>The knapsack has a total weight W</li>\n</ul>\n<p>Task:</p>\n<ul>\n<li>Determine set S of items of max value that can be contained in knapsack</li>\n</ul>\n<p>Divisible:</p>\n<ul>\n<li>Items do not have to be included in entirety</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sort items in decresing order of c/w\ni = 1\ncurrentW = 0\nwhile currentW + w_i &lt; W\n\ttake item of weight w_i and cost c_i\n\tcurrentW += w_i\n\ti++\ntake W-currentW portion of item i</code></pre></div>\n<p>Indivisible:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function(n,c,w,W)\nif n &lt;= 0\n\treturn 0\nif W &lt; w_n\n\twithLastItem = -1\nelse\n\twithLastItem = c_n + function(n-1,c,w,W-w_n)\nwithoutLastItem = function(n-1,c,w,W)\nreturn max{withLast,withoutLast}</code></pre></div>\n<ul>\n<li>Create knapsack with subproblems</li>\n<li>let S[k][v] := the solution with first k items and available weight v</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">init S[0][v] = 0\ninit S[k][0] = 0\nfor v from 1 to W\n\tfor k from 1 to n\n\t\tS[k][v] = S[k-1][v]\n\t\tif w_k &lt;= v and S[k-1][v-w_k] + c_k > S[k][v]\n\t\t\tS[k][v] = S[k-1][v-w_k] + c_k\nreturn S[n][W]</code></pre></div>\n<h4>Longest Increasing Subsequence</h4>\n<h3>Graph Algorithms</h3>\n<p>A graph is usually defined as having a number of vertices V and a number of\nedges E with or without weights.</p>\n<h4>Prim’s Algorithm</h4>\n<ul>\n<li>Finds Min-Span Tree</li>\n<li>Greedy</li>\n<li>O(V^2)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Choose an arbitrary starting vertex\n2. Of edges that connect to the tree, add the minimum-weight one\n3. Repeat until all vertices are accounted for</code></pre></div>\n<h4>Dijkstra’s Algorithm</h4>\n<ul>\n<li>Shortest path between nodes with non-negative edges</li>\n<li>O(V^2)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Choose starting vertex\n2. Assign each node dist: 0 for starting, inf otherwise\n3. For current, consider all neighbors and calc tentative dists.\n\t\tCompare with previous value and assign smaller\n4. Mark the current node as visited and remove from unvisited set\n5. if destination has been reached, terminate\n\t   else take 'shortest' unvisited node path, set as new current, and 3)</code></pre></div>\n<h4>Floyd Warshall</h4>\n<ul>\n<li>Compares all possible paths through the graph between each pair of vertices</li>\n<li>O(V^3)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let dist be a |V| x |V| array of minimum dists at infinity\nfor each vertex v\n\tdist[v][v] = 0\nfor each edge (u,v)\n\tdist[u][v] = w(u,v) // the weight of the edge (u,v)\nfor k from 1 to |V|\n\tfor i from 1 to |V|\n\t\tfor j from 1 to |V|\n\t\t\tif dist[i]][j] > dist[i][k] + dist[k][j]\n\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j]\n\t\t\tend if</code></pre></div>\n<h4>Bellman-Ford</h4>\n<ul>\n<li>Computes shortest path from source vertex to all other vertices</li>\n<li>Slower than Dijkstras</li>\n<li>but can handle negative values</li>\n<li>Runs in O(|V||E|)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for each vertex v in vertices:\n\tdist[v]    = inf\n\tpredecessor[v] = null;\ndist[source] = 0\n\nfor i from 1 to size(vertices)-1:\n\tfor each edge (u,v) with weight w in edges:\n\t\tif dist[u] + w &lt; dist[v]:\n\t\t\tdist[v] = dist[u] + w\n\t\t\tpredecessor[v] = u\n\nfor each edge (u,v) with weight w in edges:\n\tif dist[u] + w &lt; dist[v]:\n\t\terror \"Graph contains a negative-weight cycle\"\nreturn dist,predecessor</code></pre></div>\n<h4>Kruskal</h4>\n<h4>Ford-Fulkerson</h4>\n<ul>\n<li>Greedy Algorithm</li>\n<li>Computes maximum flow in a flow network</li>\n<li>Complexity: O(Ef); E edges, f maximum flow</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">given G = (V,E) with flow capacity c, source s, and sink t\nf(u,v) = 0 for all edges(u,v)\nwhile there is a path from s to t in G_f, with c_f(u,v) > 0 for all edges:\n\tfind c_f(p) = min(c_f(u,v):(u,v))\n\tfor each edge (u,v)\n\t\tf(u,v) += c_f(p)\n\t\tf(v,u) -= c_f(p)\n</code></pre></div>","excerpt":"Basic Concepts Complexity An algorithm is efficient if it runs in polynomial time or better. Big-O Denotes worst case running time, a bound…","frontmatter":{"title":"Algorithms Review Cheat Sheet","date":"2017-05-13"}}},"pageContext":{"slug":"/2017-5-13-algo-review/"}},"staticQueryHashes":["1963140206"]}